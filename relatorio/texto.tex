\section{Problema da Seleção}

Obtenção dos $1 \leq k \leq n$ menores elementos de um dado vetor $V$ de tamanho $n$.

\subsection{Método 1: Busca dos Menores Elementos}

O primeiro método de seleção implementado consiste na busca do menor elemento de $V$, que é então removido do vetor, repetindo o processo $k$ vezes para encontrar os $k$ menores. Então, o tempo de execução do algoritmo fica em ordem $T_1(n, k) = \sum_{i = 0}^{k-1} (n - i) + \Theta(1) = \Theta(k n)$. No pior caso, como $k \in O(n)$, a complexidade se torna $T_1(n) \in O\left(n^2\right)$.

\subsection{Método 2: Quicksort}

Para o segundo método foi utilizada a função dada que realiza a ordenação completa do vetor para que a seleção dos menores elementos seja em tempo constante. Logo, a ordenação, que no caso é feita com o Quicksort, domina o tempo de execução e a complexidade de pior caso se torna $T_2(n, k) = \Theta\left(n^2\right)$. Entretanto, no caso médio o Quicksort consegue uma complexidade $\Omega(n \lg n)$, que pode ser esperada nas implementações do algoritmo.

\subsection{Método 3: Heap de Mínimo}

O último método se baseia na construção de um heap de mínimo, onde as seleções de menor elemento podem ser feitas de forma eficiente. Assim, o heap pode ser montado a partir de $V$ em tempo $\Theta(n)$ e as extrações do mínimo são feitas em $O(\lg n)$. Então, a complexidade desse método fica $T_3(n, k) = \Theta(n) + \sum_{i = 0}^{k - 1} O(\lg (n - i)) = O(n + k \lg n)$, que o esperado já que os elementos de $V$ são em sua maioria distintos. No pior caso, podemos dizer também que $T_3(n) \in O(n \lg n)$.
